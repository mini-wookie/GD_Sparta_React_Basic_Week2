{"ast":null,"code":"var _jsxFileName = \"/Users/wookie/sparta/week2-assignment/src/SwipeItem.js\",\n    _s = $RefreshSig$();\n\nimport React from \"react\";\nimport styled from \"styled-components\";\nimport img from \"./scc_img01.png\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SwipeItem = /*#__PURE__*/React.memo(_c = _s(({\n  onSwipe\n}) => {\n  _s();\n\n  const swipe_div = React.useRef(null);\n  let swipe_status = \"ready\";\n  let target_classname = \"\";\n  let coordinate = {\n    start_x: 0,\n    start_y: 0,\n    end_x: 0,\n    end_y: 0\n  };\n  React.useEffect(() => {\n    const reset = () => {\n      //   console.log(\"in reset\");\n      swipe_status = \"ready\";\n      coordinate = {\n        start_x: 0,\n        start_y: 0,\n        end_x: 0,\n        end_y: 0\n      };\n      swipe_div.current.className = target_classname;\n      swipe_div.current.style.left = 0 + \"px\";\n      swipe_div.current.style.top = 0 + \"px\";\n    };\n\n    const touchStart = e => {\n      //   console.log(\"start\");\n      // 터치 시작 시, swipe_status를 touchstart로 변경해줍니다.\n      // 그리고 터치 시작한 좌표를 기록합니다!\n      // (중요! 그래야 터치 종료할 때 위치를 보고 왼쪽인지, 오른쪽인지 판별할 수 있겠죠!)\n      swipe_status = \"touchstart\";\n      target_classname = swipe_div.current.className; // console로 터치 이벤트가 시작될 때 좌표를 확인해볼까요?\n      //   console.log(e.touches[0]);\n      //   console.log(e.touches[0].clientX);\n      //   console.log(e.touches[0].clientY);\n      //   좌표도 기록해줍니다 :)\n\n      coordinate = { ...coordinate,\n        start_x: e.touches[0].clientX,\n        start_y: e.touches[0].clientY\n      };\n    };\n\n    const touchEnd = e => {\n      swipe_status = \"touchend\"; //  touchEnd이벤트는 touches 대신, changedTouches가 있어요.\n      //   console.log(e.changedTouches[0]);\n\n      coordinate = { ...coordinate,\n        end_x: e.changedTouches[0].clientX,\n        end_y: e.changedTouches[0].clientY\n      }; //   x좌표 이동 거리를 구해줍니다.\n\n      let diff_x = coordinate.end_x - coordinate.start_x; //   스와이프 방향 / 기본은 left로 뒀습니다!\n\n      let direct = \"left\"; // Match.abs() : 절대값을 구해주는 친구입니다.\n\n      if (Math.abs(diff_x) > 50) {\n        swipe_div.current.className = target_classname + \" swipe\"; // 움직인 방향에 따라 더 옴직이고 투명도를 0으로 (점점 사라지게) 줘봐요!\n\n        if (diff_x > 0) {\n          // console.log('move right');\n          direct = \"right\";\n          swipe_div.current.style.left = diff_x + 150 + \"px\";\n          swipe_div.current.style.opacity = 0;\n        } else {\n          direct = \"left\"; // console.log('move left');\n          //   console.log(diff_x - 150);\n\n          swipe_div.current.style.left = diff_x - 150 + \"px\";\n          swipe_div.current.style.opacity = 0;\n        } // 300 ms후 reset 해줍니다!\n        // 이 300ms는 props로 받아서 처리해줘도 좋겠네요!\n        // props로 받아온, 콜백 함수도 여기서 처리해줄게요!\n\n\n        window.setTimeout(() => {\n          reset();\n          onSwipe(direct);\n        }, 300);\n        return;\n      } //   reset 해줍니다.\n\n\n      reset();\n    };\n\n    const touchMove = e => {\n      // 스와이프 중 다른 이벤트가 발생하는 것을 막아줍니다\n      e.preventDefault(); //   console.log(\"in touch move!\");\n      // 현재 좌표(이동 중인 좌표)를 기록해줍니다.\n\n      let current_coordinate = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      }; //   콘솔로 이동한 값이 어떻게 나오는 지 한번 확인해볼까요?\n      //   console.log(\n      //     current_coordinate.x - coordinate.start_x,\n      //     current_coordinate.y - coordinate.start_y\n      //   );\n      //   터치 중일 때 div가 따라 움직이도록 해줍시다!\n\n      swipe_div.current.style.left = current_coordinate.x - coordinate.start_x + \"px\";\n      swipe_div.current.style.top = current_coordinate.y - coordinate.start_y + \"px\";\n    }; // 터치 이벤트가 취소될 경우 원래 상태로 돌려줍니다!\n\n\n    const touchCancel = e => {\n      swipe_status = \"cancel\";\n      reset();\n    };\n\n    swipe_div.current.addEventListener(\"touchstart\", touchStart);\n    swipe_div.current.addEventListener(\"touchend\", touchEnd);\n    swipe_div.current.addEventListener(\"touchmove\", touchMove);\n    swipe_div.current.addEventListener(\"touchcancel\", touchCancel); // 이부분은 이벤트 해제 부분이에요!\n\n    return () => {\n      // 만약 이벤트 걸었던 엘리먼트가 없으면 해제하지 않습니다!\n      if (!swipe_div.current) {\n        return;\n      }\n\n      swipe_div.current.removeEventListener(\"touchstart\", touchStart);\n      swipe_div.current.removeEventListener(\"touchend\", touchEnd);\n      swipe_div.current.removeEventListener(\"touchmove\", touchMove);\n      swipe_div.current.removeEventListener(\"touchcancel\", touchCancel);\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(DragItem, {\n    ref: swipe_div,\n    children: /*#__PURE__*/_jsxDEV(\"img\", {\n      src: img\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 151,\n    columnNumber: 5\n  }, this);\n}, \"/IC+tqoEKY08no19w1c4a8bdE4I=\"));\n_c2 = SwipeItem;\nconst DragItem = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n\n  &.swipe {\n    transition: 300ms;\n  }\n\n  & > div {\n    border-radius: 500px;\n    background-color: #ffd6aa;\n  }\n  & img {\n    max-width: 150px;\n  }\n`;\n_c3 = DragItem;\nSwipeItem.defaultProps = {\n  onSwipe: direction => {}\n};\nexport default SwipeItem;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"SwipeItem$React.memo\");\n$RefreshReg$(_c2, \"SwipeItem\");\n$RefreshReg$(_c3, \"DragItem\");","map":{"version":3,"sources":["/Users/wookie/sparta/week2-assignment/src/SwipeItem.js"],"names":["React","styled","img","SwipeItem","memo","onSwipe","swipe_div","useRef","swipe_status","target_classname","coordinate","start_x","start_y","end_x","end_y","useEffect","reset","current","className","style","left","top","touchStart","e","touches","clientX","clientY","touchEnd","changedTouches","diff_x","direct","Math","abs","opacity","window","setTimeout","touchMove","preventDefault","current_coordinate","x","y","touchCancel","addEventListener","removeEventListener","DragItem","div","defaultProps","direction"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport styled from \"styled-components\";\nimport img from \"./scc_img01.png\";\n\nconst SwipeItem = React.memo(({ onSwipe }) => {\n  const swipe_div = React.useRef(null);\n  let swipe_status = \"ready\";\n  let target_classname = \"\";\n  let coordinate = {\n    start_x: 0,\n    start_y: 0,\n    end_x: 0,\n    end_y: 0,\n  };\n\n  React.useEffect(() => {\n    const reset = () => {\n      //   console.log(\"in reset\");\n      swipe_status = \"ready\";\n\n      coordinate = {\n        start_x: 0,\n        start_y: 0,\n        end_x: 0,\n        end_y: 0,\n      };\n\n      swipe_div.current.className = target_classname;\n\n      swipe_div.current.style.left = 0 + \"px\";\n      swipe_div.current.style.top = 0 + \"px\";\n    };\n\n    const touchStart = (e) => {\n      //   console.log(\"start\");\n\n      // 터치 시작 시, swipe_status를 touchstart로 변경해줍니다.\n      // 그리고 터치 시작한 좌표를 기록합니다!\n      // (중요! 그래야 터치 종료할 때 위치를 보고 왼쪽인지, 오른쪽인지 판별할 수 있겠죠!)\n      swipe_status = \"touchstart\";\n      target_classname = swipe_div.current.className;\n      // console로 터치 이벤트가 시작될 때 좌표를 확인해볼까요?\n      //   console.log(e.touches[0]);\n      //   console.log(e.touches[0].clientX);\n      //   console.log(e.touches[0].clientY);\n\n      //   좌표도 기록해줍니다 :)\n      coordinate = {\n        ...coordinate,\n        start_x: e.touches[0].clientX,\n        start_y: e.touches[0].clientY,\n      };\n    };\n\n    const touchEnd = (e) => {\n      swipe_status = \"touchend\";\n      //  touchEnd이벤트는 touches 대신, changedTouches가 있어요.\n      //   console.log(e.changedTouches[0]);\n      coordinate = {\n        ...coordinate,\n        end_x: e.changedTouches[0].clientX,\n        end_y: e.changedTouches[0].clientY,\n      };\n\n      //   x좌표 이동 거리를 구해줍니다.\n      let diff_x = coordinate.end_x - coordinate.start_x;\n      //   스와이프 방향 / 기본은 left로 뒀습니다!\n      let direct = \"left\";\n\n      // Match.abs() : 절대값을 구해주는 친구입니다.\n      if (Math.abs(diff_x) > 50) {\n        swipe_div.current.className = target_classname + \" swipe\";\n\n        // 움직인 방향에 따라 더 옴직이고 투명도를 0으로 (점점 사라지게) 줘봐요!\n        if (diff_x > 0) {\n          // console.log('move right');\n          direct = \"right\";\n          swipe_div.current.style.left = diff_x + 150 + \"px\";\n          swipe_div.current.style.opacity = 0;\n        } else {\n          direct = \"left\";\n          // console.log('move left');\n          //   console.log(diff_x - 150);\n          swipe_div.current.style.left = diff_x - 150 + \"px\";\n          swipe_div.current.style.opacity = 0;\n        }\n\n        // 300 ms후 reset 해줍니다!\n        // 이 300ms는 props로 받아서 처리해줘도 좋겠네요!\n        // props로 받아온, 콜백 함수도 여기서 처리해줄게요!\n        window.setTimeout(() => {\n          reset();\n          onSwipe(direct);\n        }, 300);\n        return;\n      }\n\n      //   reset 해줍니다.\n      reset();\n    };\n\n    const touchMove = (e) => {\n      // 스와이프 중 다른 이벤트가 발생하는 것을 막아줍니다\n      e.preventDefault();\n\n      //   console.log(\"in touch move!\");\n      // 현재 좌표(이동 중인 좌표)를 기록해줍니다.\n      let current_coordinate = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY,\n      };\n\n      //   콘솔로 이동한 값이 어떻게 나오는 지 한번 확인해볼까요?\n      //   console.log(\n      //     current_coordinate.x - coordinate.start_x,\n      //     current_coordinate.y - coordinate.start_y\n      //   );\n\n      //   터치 중일 때 div가 따라 움직이도록 해줍시다!\n      swipe_div.current.style.left =\n        current_coordinate.x - coordinate.start_x + \"px\";\n      swipe_div.current.style.top =\n        current_coordinate.y - coordinate.start_y + \"px\";\n    };\n\n    // 터치 이벤트가 취소될 경우 원래 상태로 돌려줍니다!\n    const touchCancel = (e) => {\n      swipe_status = \"cancel\";\n      reset();\n    };\n\n    swipe_div.current.addEventListener(\"touchstart\", touchStart);\n    swipe_div.current.addEventListener(\"touchend\", touchEnd);\n    swipe_div.current.addEventListener(\"touchmove\", touchMove);\n    swipe_div.current.addEventListener(\"touchcancel\", touchCancel);\n\n    // 이부분은 이벤트 해제 부분이에요!\n    return () => {\n      // 만약 이벤트 걸었던 엘리먼트가 없으면 해제하지 않습니다!\n      if (!swipe_div.current) {\n        return;\n      }\n      swipe_div.current.removeEventListener(\"touchstart\", touchStart);\n      swipe_div.current.removeEventListener(\"touchend\", touchEnd);\n      swipe_div.current.removeEventListener(\"touchmove\", touchMove);\n      swipe_div.current.removeEventListener(\"touchcancel\", touchCancel);\n    };\n  }, []);\n\n  return (\n    <DragItem ref={swipe_div}>\n      <img src={img} />\n    </DragItem>\n  );\n});\n\nconst DragItem = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n\n  &.swipe {\n    transition: 300ms;\n  }\n\n  & > div {\n    border-radius: 500px;\n    background-color: #ffd6aa;\n  }\n  & img {\n    max-width: 150px;\n  }\n`\n\nSwipeItem.defaultProps = {\n  onSwipe: (direction) => {},\n};\n\nexport default SwipeItem;"]},"metadata":{},"sourceType":"module"}